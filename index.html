<!DOCTYPE html>
<html>

  <head>
    <title>Verifiable Credentials Overview</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>

    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "DNOTE",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "vc-overview",

        // if you wish the publication date to be other than today, set this
        //publishDate:  "2023-11-07",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://w3c.github.io/vc-overview/",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        //extraCSS:             ["spec.css", "prettify.css"],

        // editors, add as many as you like
        // only "name" is required
        editors: [
          // {
          //   name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          //   company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          //   w3cid: 41758
          // },
          {
            name: "Ivan Herman", url: "https://www.w3.org/People/Ivan/",
            company: "W3C", companyURL: "https://www.w3.org",
            w3cid: 7382, orcid: "0000-0003-0782-2704"
          },
        ],

        authors: [
          {
            name: "Greg Bernstein", url: "https://www.grotto-networking.com/",
            company: "Invited Expert", w3cid: 140479
          },
          {
            name: "Daniel C. Burnett", url: "https://www.linkedin.com/in/daburnett/",
            company: "ConsenSys", companyURL: "https://consensys.net/",
            w3cid: 37473
          },

          {
            name: "David Chadwick",
            url: "https://www.linkedin.com/in/davidwchadwick/",
            company: "Crossword Cybersecurity PLC",
            companyURL: "https://www.crosswordcybersecurity.com/",
            w3cid: 46156
          },
          {
            name: "Gabe Cohen", url: "https://github.com/decentralgabe",
            company: "Block", companyURL: "https://block.xyz/",
            w3cid: 116851
          },
          {
            name: "Michael B. Jones", url: "https://self-issued.info/",
            company: "Invited Expert",
            w3cid: 38745
          },
          {
            name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 48025
          },
          {
            name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758
          },
          {
            name: "Orie Steele", url: "https://github.com/OR13",
            company: "Transmute",
            companyURL: "https://www.transmute.industries/",
            w3cid: 109171
          },
          {
            name: "Ted Thibodeau Jr", url: "https://github.com/TallTed",
            company: "OpenLink Software", companyURL: "https://www.openlinksw.com/",
            w3cid: 42501
          },
          {
            name: "Brent Zundel", url: "https://www.linkedin.com/in/bzundel/",
            company: "mesur.io", companyURL: "https://www.mesur.io",
            w3cid: 102128
          },

        ],

        // name of the WG
        group: "vc",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-vc-wg",

        github: "w3c/vc-overview",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        //wgPatentURI:  "",
        maxTocLevel: 4,
        lint: { "informative-dfn": false },

        /*preProcess: [ ],
        alternateFormats: [ {uri: "diff-20111214.html", label: "diff to previous version"} ],
        */
        localBiblio: {
          "MULTIBASE": {
            title: "The Multibase Data Format",
            date: "February 2023",
            href: "https://datatracker.ietf.org/doc/draft-multiformats-multibase",
            authors: [
              "Juan Benet",
              "Manu Sporny"
            ],
            status: "Internet-Draft",
            publisher: "IETF"
          },
          "MULTIHASH": {
            title: "The Multihash Data Format",
            date: "February 2023",
            href: "https://datatracker.ietf.org/doc/draft-multiformats-multihash",
            authors: [
              "Juan Benet",
              "Manu Sporny"
            ],
            status: "Internet-Draft",
            publisher: "IETF"
          },
          "MULTICODEC": {
            title: "The Multi Codec Encoding Scheme",
            date: "February 2022",
            href: "https://github.com/multiformats/multicodec/blob/master/table.csv",
            authors: [
              "The Multiformats Community"
            ],
            status: "Internet-Draft",
            publisher: "IETF"
          },
          "SD-JWT": {
            title: "Selective Disclosure for JWTs (SD-JWT)",
            href: "https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/",
            authors: [
              "Daniel Fett",
              "Kristina Yasuda",
              "Brian Campbell"
            ],
            status: "I-D",
            publisher: "The IETF OAuth Working Group"
          },
          "CFRG-BBS-SIGNATURE": {
            title: "The BBS Signature Scheme",
            href: "https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html",
            authors: [
              "Tobias Looker",
              "Vasilis Kalos",
              "Andrew Whitehead",
              "Mike Lodder",
            ],
            status: "I-D",
            publisher: "IETF"
          }
        },
        // postProcess: [restrictRefs],
      };
    </script>
    <style>
      code {
        color: rgb(199, 73, 0);
        font-weight: bold;
      }

      pre.nohighlight {
        overflow-x: auto;
        white-space: pre-wrap;
      }

      ol.algorithm {
        counter-reset: numsection;
        list-style-type: none;
      }

      ol.algorithm li {
        margin: 0.5em 0;
      }

      ol.algorithm li:before {
        font-weight: bold;
        counter-increment: numsection;
        content: counters(numsection, ".") ") ";
      }

    </style>
  </head>

  <body>
    <section id='abstract'>
      <p>
          Credentials are a part of our daily lives; driver's licenses are used to assert that we are capable of operating a motor vehicle, university degrees can be used to assert our level of education, and government-issued passports enable us to travel between countries. 
          The family of Recommendations for Verifiable Credentials, described in this overview document, provide a mechanism to express these sorts of credentials on the Web in a way that is cryptographically secure, privacy respecting, and machine-verifiable.
      </p>    
    </section>

    <section id='sotd'>

    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        This document provides a non-normative, high-level overview of W3C’s Verifiable Credentials and serves as a roadmap for the documents that define, describe, and secure these credentials.
        It is not the goal of being very precise, nor does this overview cover all the details. 
        The intention is to provide users, implementers, or anyone interested in the subject, an idea of the general concepts and how the various recommendations, published by the Verifiable Credentials Working Group fit together.
      </p>

      <section>
        <h2>High Level View of the Specifications</h2>
        <p>
          <a href="#overall"></a> provides and overview of the main building blocks of Verifiable Credentials, including their (normative) dependencies.
        </p>
        <p>
          The [[[VC-DATA-MODEL-2.0]]] [[VC-DATA-MODEL-2.0]] specification, which defines the core concepts that all other specifications depend on, plays a central role.
          Applications express their specific credentials using a serialization of this data model in, for example, JSON.
        </p>

        <p>
          When Verifiable Credentials are serialized in JSON it is important to trust that the structure of Credentials may be interpreted in a consistent manner by all participants of verifiable credential ecosystem.
          The [[[VC-JSON-SCHEMA]]] [[VC-JSON-SCHEMA]] defines how [[JSON-SCHEMA]] can be used for that purpose.
        </p>

        <p>
          Credentials can be secured using two different mechanisms: [=enveloping proofs=] or [=embedded proofs=].
          In both cases, a proof secures a Credential by cryptographic means (for example, digital signatures), which can be verified by a “verifier” (for example, the receiver of the credential).
          In the enveloping case the proof wraps the Credential, whereas a embedded proofs are included in the serialization of the Credential itself.
        </p>

        <p>
          A family of enveloping proofs is defined in the [[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]] document, relying on technologies defined by the IETF.
          They are based on JSON Object Signing and Encryption (<a href="https://datatracker.ietf.org/wg/jose/about/">JOSE</a>), Selective Disclosure for JWTs [[SD-JWT]], or CBOR Object Signing and Encryption (COSE) [[RFC9052]]. 
          Other types of embedded proofs may be specified by the community.
        </p>

        <p>
          The general structure for embedded proofs is defined in a separate [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]] specification.
          Some instantiations of this general structure are also specified by the Working Group in the forms of “cryptosuites” specifications: [[[VC-DI-EDDSA]]] [[VC-DI-EDDSA]], [[[VC-DI-ECDSA]]] [[VC-DI-ECDSA]], and [[[VC-DI-BBS]]] [[VC-DI-BBS]]. 
          Other cryptosuites may be specified by the community.
        </p>

        <p>
          Finally, the [[[VC-BITSTRING-STATUS-LIST]]] [[VC-BITSTRING-STATUS-LIST]] specification defines a privacy-preserving, space-efficient, and high-performance mechanism for publishing status information such as suspension or revocation of Verifiable Credentials through use of bitstrings.
        </p>

        <figure id="overall">
          <img style="margin: auto; display: block; width: 100%;" src="diagrams/VCWG_specifications.svg" alt="TBD">
          <figcaption style="text-align: center;">
            Verifiable Credentials Working Group Recommendations
          </figcaption>
        </figure>
      </section>
    </section>

    <section>
      <h3>Ecosystem Overview</h3>
      <p>
        The Verifiable Credential specifications rely on an ecosystem consisting of entities that play different “roles”.
        The main roles are:
      </p>
    
      <dl>
        <dt>Issuer</dt>
        <dd>
          An entity that <em>creates</em> a credential, consisting of a series of claims related to the subject of a
          Credential.
          An example is a university that issues credentials for university degrees or that want to officially state that a
          person is indeed an alumni.
        </dd>
    
        <dt>Holder</dt>
        <dd>
          An entity that <em>possesses</em> on or more Credentials, and who can transmit <em>presentations</em> of those
          Credentials to third parties.
          An example may be the person who “holds“ his/her own educational degrees.
        </dd>
    
        <dt>Verifier</dt>
        <dd>
          An entity that performs verification on a Credential to check the validity, consistency, etc., of a credential.
          An example may be an employer who intends to check the validity of a university degree before deciding on the
          employment of a person.
        </dd>
      </dl>
    
      <p>
        For a more precise definition of these roles, as well as possible other roles, see the relevant <a
          data-cite="VC-DATA-MODEL-2.0#ecosystem-overview">section</a> in the data model specification.
      </p>
    
      <figure id="roles">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/ecosystem.svg" alt="diagram showing how
                            credentials flow from issuer to holder and
                            presentations flow from holder to verifier where all
                            three parties can use information from a logical
                            verifiable data registry">
        <figcaption style="text-align: center;">
          The roles and information flows forming the basis for the VC Data Model.
        </figcaption>
      </figure>
    </section>

    <section>
      <h2>Verifiable Credentials Data Model</h2>

      <section>
        <h3>Basic Structure</h3>
        <section>
          <h4>Claims, Properties</h4>
          <p>
            A core concept is that of “claims”: statements made about various entities, referred to as “subjects”. 
            Subjects may be the holders, issuers, or verifiers as listed above, but may also be any other person (e.g., the person holding a university degree), an animal, an abstract concepts, etc. 
            Claims are expressed using “properties” referring to “values”. 
          </p>

          <figure id="basic-structure">
            <img style="margin: auto; display: block; width: 80%;" src="diagrams/claim.svg" alt="subject has a property which
                      has a value">
            <figcaption style="text-align: center;">
              The basic structure of a claim with a literal value.
            </figcaption>
          </figure>

          <p>
            Values may be literals, but may also be other entities, referred to, usually, by a URL[[URL]]. It the latter case, the  entity may become the subject of another claim; these claims, together, can be seen as a “graph” of claims that, together, form a Credential. 
            See <a href="#credential-example-claims"></a> for and example of such a graph or, for more complex examples, the [[[VC-DATA-MODEL-2.0]]] specification itself. 
          </p>

          <p>
            The [[[VC-DATA-MODEL-2.0]]] document specifies a number of standard properties. These include, for example, `credentialSubject`, `type`, `issuer`, `validFrom`, etc. Developers may define their own properties to be used for a specific kind of Credentials, like a driving license, university degrees, or marriage certificates.
          </p>
        </section>

        <section>
          <h4>Verifiable Credentials</h4>

          <p>
            A Credential is a set of one or more claims made by the same entity.
            Credentials might also include an identifier and metadata to describe properties of the credential, such as the issuer, the validity date and time period, a representative image, the revocation mechanism, and so on. 
            A <em>Verifiable</em> Credential is a set of claims and metadata that also includes verification mechanisms that cryptographically prove who issued it.
          </p>

          <p>
            For a more detailed description of abstract Credentials, with examples, see the relevant <a
              data-cite="VC-DATA-MODEL-2.0#credentials">section</a> in the data model specification.
          </p>

          <figure id="basic-vc">
            <img style="margin: auto; display: block; width: 35%;" src="diagrams/vc.svg" alt="a Verifiable
                        Credential contains Credential Metadata, Claim(s), and
                        Proof(s)">
            <figcaption style="text-align: center;">
              Basic components of a Verifiable Credential.
            </figcaption>
          </figure>
        </section>

        <section>
          <h4>Verifiable Presentations</h4>
          <p>
            Enhancing privacy is a key design feature of Verifiable Credentials. 
            Therefore, it is important for entities using this technology to be able to express only the portions of their persona that are appropriate for a given situation.
            The expression of a subset of one's persona is called a <em>Verifiable Presentation</em>. 
            Examples of different personas include a person’s professional persona, their online gaming persona, their family persona, or an incognito persona.
          </p>
          
          <p>
            A Verifiable Presentation is created by a holder, can express data from multiple Verifiable Credentials, and can contain arbitrary additional metadata in forms of additional claims. 
            They are used to present claims to a verifier. 
            It is also possible to present Verifiable Credential directly.
          </p>

          <p>
            A Verifiable Presentation is usually short-lived, it is not meant at being stored for a longer period.
          </p>

          <figure id="basic-vp">
            <img style="margin: auto; display: block; width: 35%;" src="diagrams/presentation.svg" alt="A Verifiable
                      Presentation contains Presentation Metadata, Verifiable
                      Credential(s), and Proof(s)">
            <figcaption style="text-align: center;">
              Basic components of a verifiable presentation.
            </figcaption>
          </figure>
        </section>
      </section>
      <section>
        <h3>Serialization in JSON</h3>

        <p>
          In [[VC-DATA-MODEL-2.0]], Verifiable Credentials and Presentations are expressed in JSON [[RFC7519]], more specifically [[JSON-LD11]]. 
          In this serialization, properties of claims are represented as JSON names, and values as JSON literals or objects.
          Subjects of claims are either explicitly identified by an `id` property, or implicitly by appearing as an object of another claim.
        </p>

        <p>
          Standard properties defined by the [[VC-DATA-MODEL-2.0]] form a distinct set of JSON names, also referred to as a <em>vocabulary</em>.
          An important characteristics of Verifiable Credentials in JSON-LD is that it favors a decentralized and permissionless approach to <em>extend</em> to a new application area through additional set of properties, i.e., vocabularies, distributed on the Web: anyone can “publish” such a vocabulary, following some rules described in the <a data-cite="VC-DATA-MODEL-2.0#Extensibility">extensibility section</a> of the specification.
        </p>

        <p>
          The following figure is an example for a simple Credential. It states that the person named "Pat", identified by `https://www.exampl.org/persons/pat`, is an alumni of the Example University (identified by `did:example:c276e12ec21ebfeb1f712ebc6f1`).
          The Credential is valid from the 1st of January 2010, and is issued by an entity identified by `did:example:2g55q912ec3476eba2l9812ecbfe`.
          Most of the properties in the Credential are from the standard Verifiable Credentials vocabulary, but some terms (like `alumniOf`, `AlumniCredential`) are added by the application-specific vocabulary referred to by `https://www.example.org/vocabs/alumni`.
        </p>

        <pre id="base_example" class="example nohighlight" title="A Simple Credential">
        {
          "@context": [
            "https://www.w3.org/ns/credentials/v2",
            "https://www.example.org/vocabs/alumni"
          ],
          "id": "https://university.example/Credential123",
          "type": ["VerifiableCredential", "ExampleAlumniCredential"],
          "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
          "validFrom": "2010-01-01T00:00:00Z",
          "credentialSubject": {
            "id": "https://www.example.org/persons/pat",
            "name": "Pat",
            "alumniOf": {
              "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
              "name": "Example University"
            }
          }
        }
        </pre>

        <p>
          <a href="#credential-example-claims"></a> shows the same Credential, but represented as a graph of claims, as described in <a href="#claims-properties"></a>.
        </p>

        <figure id="credential-example-claims">
          <img style="margin: auto; display: block; width: 100%;" src="diagrams/credential_example.svg" alt="A Verifiable
                              Presentation contains Presentation Metadata, Verifiable
                              Credential(s), and Proof(s)">
          <figcaption style="text-align: center;">
            Credential in <a href="#base_example"></a> represented as a collection of claims.
          </figcaption>
        </figure>

        <p>
          The Credential in <a href="#base_example"></a>, issued by Example University, is stored by a holder (who may be simple the subject of the credential, i.e., John Doe). On request, the holder may “present” a Credential to a verifier, by encapsulating the Credential in a Verifiable Presentation. This is how the result looks like in the JSON-LD serialization:
        </p>

        <pre class="example nohighlight" title="Presenting the Credential">
          {
            "@context": [
              "https://www.w3.org/ns/credentials/v2",
              "https://www.example.org/vocabs/alumni"
            ],
            "type": "VerifiablePresentation",
            "id" : "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b",
            "holder": "did:example:12345678",
            "validUntil": "2020-12-31T00:00:00Z"
            "verifiableCredential": {
              "id": "https://university.example/Credential123",
              "type": ["VerifiableCredential", "ExampleAlumniCredential"],
              "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
              "validFrom": "2010-01-01T00:00:00Z",
              "credentialSubject": {
                "id": "https://www.example.org/persons/pat",
                "name": "Pat",
                "alumniOf": {
                  "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
                  "name": "Example University"
                }
              }
            }
          }
        </pre>

        <p>
          Note that the holder could have presented several Credentials within the same presentation or create a new Credential by either combining it with others or removing some claims as irrelevant for the specific context. 
        </p>


      </section>
      <section>
        <h4>Checking Structure with JSON Schemas</h4>

        <p>
          A significant part of the integrity of a Verifiable Credential comes from the ability to structure its contents so that all three parties — issuer, holder, verifier — may have a consistent mechanism of trust in interpreting the data that they are provided with.
          One way of doing that is to use [[JSON-SCHEMA]] the check the validity of the Credential.
          The [[[VC-JSON-SCHEMA]]] [[VC-JSON-SCHEMA]] specifications adds some standard properties to express the association of a Credential with a JSON Schema.
          Consider the following example:
        </p>

        <pre id="base_example_schema" class="example nohighlight" title="A Simple Credential with a JSON Schema">
          {
            "@context": [
              "https://www.w3.org/ns/credentials/v2",
              "https://www.example.org/vocabs/alumni"
            ],
            "id": "https://university.example/Credential123",
            "type": ["VerifiableCredential", "ExampleAlumniCredential"],
            "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
            "validFrom": "2010-01-01T00:00:00Z",
            "credentialSubject": {
              "id": "https://www.example.org/persons/pat",
              "name": "Pat",
              "alumniOf": {
                "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
                "name": "Example University"
              }
            },
            "credentialSchema" : {
              "id": "https://university.example/Credential123-schema.json",
              "type": "JsonSchema"
            }
          }
        </pre>

        <p>When dereferenced, the URL `https://university.example/Credential123-schema.json` should return a JSON Schema, for example:</p>
        
        <pre class="example nohighlight" title="JSON Schema for the Simple Credential">
          {
            "$id": "https://example.com/schemas/email.json",
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "title": "ExampleAlumniCredential",
            "description": "Alumni Credential using JsonSchema",
            "type": "object",
            "properties": {
            "credentialSubject": {
              "type": "object",
              "properties": {
                "alumniOf": {
                  "type": "string",
                  "format": "url"
                }
              },
              "required": [
                  "alumniOf"
                ]
              }
            }
          }
        </pre>

        <p>
          For security reasons one may want to go further: check/verify the JSON Schema itself. 
          This can be done by referring to the JSON Schema <em>indirectly</em> through a Verifiable Credential.
          The reference to such a Verifiable Credential looks very much like <a href="#base_example_schema"></a> except for the value of the `type`:
        </p>

        <pre class="example nohighlight" title="A Simple Credential with a JSON Schema Credential">
          {
            "@context": [
              "https://www.w3.org/ns/credentials/v2",
              "https://www.example.org/vocabs/alumni"
            ],
            "id": "https://university.example/Credential123",
            "type": ["VerifiableCredential", "ExampleAlumniCredential"],
            "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
            "validFrom": "2010-01-01T00:00:00Z",
            "credentialSubject": {
              "id": "https://www.example.org/persons/pat",
              "name": "Pat",
              "alumniOf": {
                "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
                "name": "Example University"
              }
            },
            "credentialSchema" : {
              "id": "https://university.example/Credential123-schema-credential",
              "type": "JsonSchemaCredential"
            }
          }
        </pre>

        <p>
          In this case, when dereferenced, the URL `https://university.example/Credential123-schema-credential` should return a Verifiable Credential, whose `credentialSubject` property should refer to a bona fide JSON Schema. 
          See <a data-cite="VC-JSON-SCHEMA#jsonschemacredential">the example</a> in the [[[VC-JSON-SCHEMA]]] specification for further details.
        </p>
      </section>
    </section>

    <section>
      <h2>Securing Credentials</h2>

      <section>
        <h3>Enveloping Proofs</h3>

        <p>
          Enveloping proofs of Credentials, defined by this Working Group, are based JSON Object Signing and Encryption (<a href="https://datatracker.ietf.org/wg/jose/about/">JOSE</a>), CBOR Object Signing and Encryption (COSE) [[RFC9052]], or Selective Disclosure for JWTs [[SD-JWT]]. 
          These are all based IETF specifications (or families of specifications, like JOSE that refers to JWT [[RFC7519]], JWS [[RFC7515]], or JWK [[RFC7517]]).
          The [[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]] specification makes the “bridge” between these and the [[[VC-DATA-MODEL-2.0]]],
          specifying the suitable header claims, media types, etc.
        </p>

        <p>
          The common in all approaches is that the Credential (or Presentation) is the (unencoded) “payload” (to use the IETF terminology), which is supplemented by a suitable header and, for verification, a signature.
          These are encoded, signed, and concatenated to be transferred in a compact form by one entity to an other (e.g., sent by the holder to the verifier)
          All the intricate details on signatures, encryption keys, etc., are defined by the IETF specifications; see <a href="#base_example_jwt_unencoded"></a> for a specific case.
        </p>

        <p>
          The COSE [[RFC9052]] is similar to JOSE, except that all structures are represented in CBOR [[RFC8949]].
          This results for a payload with significantly smaller footprint.
          From the Credentials point of view, however, the structure is similar insofar as the Credential (or the Presentation)
          is again the payload for COSE.
          The result is a Credential representation that can be, for example, encoded in a QR Code.
        </p>
        
        <p>
          The [[[SD-JWT]]] [[SD-JWT]] is a variant of JOSE, which allows for the selective disclosure of individual claims.
          Claims can be selectively hidden or revealed to the verifier, but nevertheless all claims are cryptographically
          protected against modification.
          This approach is obviously more complicated than the JOSE case but, from the Credentials point of view, the structure
          is similar.
          The original Credential is the payload for SD-JWT; and it is the holder’s responsibility to use the SD-JWT approach
          when presenting the Credential to a verifier using selective disclosure.
        </p>

        <section>
          <h4>A Complete Example with JOSE</h4>

          <p>
            The Credential example, shown in <a href="#base_example"></a>, and enriched with a reference to a JSON Schema in <a
              href="#base_example_schema"></a>, can be secured via an enveloping proof as follows:
          <p>
          <pre id="base_example_jwt_unencoded" class="example nohighlight" title="A Simple Credential in JWT (unencoded)">
            // Header
            {
              "iss": "did:example:2g55q912ec3476eba2l9812ecbfe",
              "alg": "HS256",
              "cty": "vc+ld+json",
              "typ": "vc+ld+json+jwt"
            }

            ---
            
            // Payload
            {
              "@context": [
                "https://www.w3.org/ns/credentials/v2",
                "https://www.example.org/vocabs/alumni"
              ],
              "id": "https://university.example/Credential123",
              "type": ["VerifiableCredential", "ExampleAlumniCredential"],
              "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
              "validFrom": "2010-01-01T00:00:00Z",
              "credentialSubject": {
                "id": "https://www.example.org/persons/pat",
                "name": "Pat",
                "alumniOf": {
                  "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
                  "name": "Example University"
                },
                "credentialSchema" : {
                  "id": "https://university.example/Credential123-schema-credential",
                  "type": "JsonSchemaCredential"
                }
              }
            }
          </pre>

          <p>
            As a next step, the header and the payload is encoded, concatenated, and then signed using the methods defined by JWS [[RFC7515]]. 
            The encoded and signed Credential could look like (depending on the signature secret):
          </p>

          <pre  id="base_example_jwt_encoded" class="example nohighlight" title="A Simple Credential Enveloped using JOSE">

            <span style="color:red">eyJpc3MiOiJkaWQ6ZXhhbXBsZToyZzU1cTkxMmVjMzQ3NmViYTJsOTgxMmVjYmZlIiwiYWxnIjoiSFMyNTYiLCJjdHkiOiJ2YytsZCtqc29uIiwidHlwIjoidmMrbGQranNvbitqd3QifQ.</span>eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvdjIiLCJodHRwczovL3d3dy5leGFtcGxlLm9yZy92b2NhYnMvYWx1bW5pIl0sImlkIjoiaHR0cHM6Ly91bml2ZXJzaXR5LmV4YW1wbGUvQ3JlZGVudGlhbDEyMyIsInR5cGUiOlsiVmVyaWZpYWJsZUNyZWRlbnRpYWwiLCJFeGFtcGxlQWx1bW5pQ3JlZGVudGlhbCJdLCJpc3N1ZXIiOiJkaWQ6ZXhhbXBsZToyZzU1cTkxMmVjMzQ3NmViYTJsOTgxMmVjYmZlIiwidmFsaWRGcm9tIjoiMjAxMC0wMS0wMVQwMDowMDowMFoiLCJjcmVkZW50aWFsU3ViamVjdCI6eyJpZCI6Imh0dHBzOi8vd3d3LmV4YW1wbGUub3JnL3BlcnNvbnMvcGF0IiwibmFtZSI6IlBhdCIsImFsdW1uaU9mIjp7ImlkIjoiZGlkOmV4YW1wbGU6YzI3NmUxMmVjMjFlYmZlYjFmNzEyZWJjNmYxIiwibmFtZSI6IkV4YW1wbGUgVW5pdmVyc2l0eSJ9LCJjcmVkZW50aWFsU2NoZW1hIjp7ImlkIjoiaHR0cHM6Ly91bml2ZXJzaXR5LmV4YW1wbGUvQ3JlZGVudGlhbDEyMy1zY2hlbWEtY3JlZGVudGlhbCIsInR5cGUiOiJKc29uU2NoZW1hQ3JlZGVudGlhbCJ9fX0.<span style="color:blue">GWlu7UyajDlXO6vCAfWuhfqcgHK2Vy1LL7BzyGk-k-E</span>
          </pre>
        </section>
      </section>

      <section>
        <h3>Embedded Proofs</h3>

        <section>
          <h4 id="di-integrity-structure">Generic Data Integrity Structure</h4>

          <p>
            The operation of Data Integrity is conceptually simple. To create a cryptographic proof, the following steps are performed: 1) Transformation, 2) Hashing, and 3) Proof Generation.
          </p>

          <figure id="di-integrity-structure-figure">
            <img style="margin: auto; display: block; width: 90%;" src="diagrams/di_crypto_proof.svg" alt="TBD">
            <figcaption style="text-align: center;">
              Generic view of the proof generation steps.
            </figcaption>
          </figure>


          <ol>
            <li>
              <em>Transformation</em> is a process described by a <em>transformation algorithm</em> that takes input data and prepares it for the hashing process.
              In the case of any kind of data serialized in JSON this transformation means to remove all the artifacts that do not influence the semantics of the data like spaces, new lines, order of JSON names, etc. 
              This step is often referred to as <em>canonicalization</em>.
            </li>
            <li>
              <em>Hashing</em> is a process described by a <em>hashing algorithm</em> that calculates an identifier for the transformed data using a
              <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a>.
              Typically, the size of the resulting hash is smaller than the data, which makes it more suitable for complex cryptographic functions like signatures.
            </li>
            <li>
              <em>Proof Generation</em> is a process described by a <em>proof method</em> that calculates a value that protects the
              integrity of the input data from modification or otherwise proves a certain desired threshold of trust.
              A typical example is the application of a cryptographic signature method using asymmetric keys, yielding the signature of the data.
            </li>
          </ol>

          <p>
            <em>Verification</em> of a proof involves repeating the same steps on the verifier’s side and, depending on the proof method, validating the proof value. 
            In the case of a signature, this test usually involves comparing the calculated signature value with the one which is embedded in the data.
          </p>
        </section>
        <section>
          <h4>VC Data Integrity</h4>

          <p>
            The [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]] specification relies on the general structure to define a set of standard properties describing the details of the proof generation process.
            The specific proof generation details (canonicalization, hash and/or proof method algorithms, etc.) are defined by <em>cryptosuites</em>. 
            The Working Group has defined a number of such cryptosuites as separate specifications, see <a href="#cryptosuites"></a> below.
          </p>

          <p>
            The core property, in the general structure, is `proof`. 
            This property embeds a claim into the Credential, referring to a separate collection of claims (a <em>ProofGraph</em>) detailing all the claims about the proof itself.
            See the example below:
          </p>

          <pre class="example nohighlight" title="Skeleton of a proof added to a Credential">
            {
              "@context": [
                "https://www.w3.org/ns/credentials/v2",
                "https://www.example.org/vocabs/alumni"
              ],
              "id": "https://university.example/Credential123",
              "type": ["VerifiableCredential", "ExampleAlumniCredential"],
              "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
              "validFrom": "2010-01-01T00:00:00Z",
              "credentialSubject": {
                "id": "https://www.example.org/persons/pat",
                "name": "Pat",
                "alumniOf": {
                  "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
                  "name": "Example University"
                }
              },
              "credentialSchema" : {
                "id": "https://university.example/Credential123-schema-credential",
                "type": "JsonSchemaCredential"
              },
              "proof" : {
                "type": "DataIntegrityProof",
                …
                // All the details about the proof
                …
                "proofValue": "zQeVb…Wx"
              }
            }
          </pre>

          <p>
            Note the `proofValue` property, whose object is the result of the proof generation process.
          </p>

          <p class="note">
            The proof value is for illustrative purposes only, and does not reflect the result of real cryptographic calculations.
          </p>

          <p>
            The <a data-cite="VC-DATA-INTEGRITY#proof">definition of `proof`</a> introduces a number of additional properties. 
            Some of these are metadata properties on the proof, like `created`, `expires`, or `domain`. 
            Others provide the necessary details on the proof generation process itself, like `cryptosuite`, `nonce` (if needed), or `verificationMethod` that usually refers to the cryptographic keys.
            The public and private keys themselves may be expressed in JWK [[RFC7517]] format or using a Multibase [[MULTIBASE]] encoding of the keys, called <a data-cite="VC-DATA-INTEGRITY#multikey">Multikey</a>.
            Details of the key formats are defined by other communities (IETF, cryptography experts, etc.) and they are very dependent on the specific cryptographic functions they operate on.
          </p>

          <p>
            It is possible to embed several proofs for the same Credentials.
            These may be a set of independent proofs (based, for example, on different cryptosuites, to accommodate to the specificities of a verifier), but may also be a “chain” of proofs that must be evaluated in a given order.
          </p>

          <p>
            A proof may also specify its “purpose” via the `proofPurpose` property: different proofs may be provided for authentication, for assertion, or for key agreement protocols.
            The verifier is supposed to choose the right proof depending on the purpose of its own operations, which is yet another possible reasons why the holder or the issuer may provide several proofs for the same Credential.
          </p>

        </section>

        <section>
          <h4>Cryptosuites</h4>


          <p>
            The Working Group publishes three cryptosuite documents: [[[VC-DI-ECDSA]]] [[VC-DI-ECDSA]], [[[VC-DI-EDDSA]]] [[VC-DI-EDDSA]], and [[[VC-DI-BBS]]] [[VC-DI-BBS]]. 
            As their name suggests, the documents rely on existing cryptographic signature schemes: the Elliptic Curve Digital Signature Algorithm (ECDSA) specification [[FIPS-186-5]], the Edwards-Curve Digital Signature Algorithm (EdDSA) specification [[RFC8032]], and the BBS Signature Scheme [[CFRG-BBS-SIGNATURE]], respectively.
          </p>
 

          <figure id="cryptosuites-diagram">
            <img style="margin: auto; display: block; width: 90%;" src="diagrams/cryptosuites.svg" alt="TBD">
            <figcaption style="text-align: center;">
              Generic view of the proof generation steps.
            </figcaption>
          </figure>

          <p>
            <a href="#cryptosuites-diagram"></a> provides an overall view of the six cryptosuites defined by the three recommendations. 
            They all implement the general structure of proofs as described in <a href="#di-integrity-structure"></a>. 
            As shown on the figure, one axes of differentiation is the data transformation function, i.e., the canonicalization of the JSON serialization: two cryptosuites use JSON Canonicalization (JCS) [[RFC8785]], the other use RDF Dataset Canonicalization (RDFC-1.0) [[RDF-CANON]]. 
            The other axis is whether the cryptosuite provides selective disclosure or not which is the case for two of the six cryptosuites.
          </p>

          <p class="note">
            A common characteristics of all these cryptosuites is that keys must always be encoded using the <a data-cite="VC-DATA-INTEGRITY#multikey">Multikey</a> encoding. 
            Also, the keys, whose exact formats are defined in the respective signature scheme specifications, also carry the choice of the hash functions to be used by the proof generation. 
            This provides yet another differentiation axis among cryptosuites although, in practice, SHA-256 [[RFC6234]] is usually used.
          </p>

          <section>
            <h5>Full Disclosure Schemes</h5>

            <p>
              The two EdDSA cryptosuites, as well as `ecdsa-rdfc-2019` and `ecdsa-jcs-2019`, follow the proof generation structure as described in <a href="#di-integrity-structure"></a>: the Credential is canonicalized (using either JCS or RDFC-1.0), the result is hashed (using the hash functions as defined by the signature key), and the proof is generated using that hash value. 
              There is, however, an extra twist: the schemes also use a set of claims called “proof options”, which are all the proof related claims that are to be embedded into the final data <em>except</em> `proofValue`. 
              This set of claims is also canonicalized and hashed following the same process as for the Credential, yielding a second hash value. 
              <em>It is the concatenation of these two values</em> that is signed by EdDSA or ECDSA, respectively, producing a value for `proofValue`.
           </p>

          </section>

          <section>
            <h5>Selective Disclosure Schemes</h5>

            <p>
              The `ecdsa-sd-2023` and `bbs-2023` cryptosuites provide selective disclosures of individual claims. 
              In both cases, the process separates the “Base Proof” (calculated by the issuer), and the “Derived Proof” (which is typically calculated by the holder when selectively presenting the credential claims to the verifier). 
              The challenge is that the verifier should check that the holder can be trusted when verifying a partial value, without having access to the full original data.
            </p>

            <p>
              To calculate the Base Proof, the Credential is supplemented with some extra information that define the “mandatory” and “non-mandatory” claims.
              Using that extra information, the transformation step described in <a href="#di-integrity-structure"></a> does not only canonicalize the Credential, but also transforms it by explicitly separating these two types of claims into their own sets.
              Furthermore, each non-mandatory claim must be signed individually, yielding a series of signatures.
              The final Base Proof is a conceptual and encoded concatenation of all these signatures and related informations like the information on mandatory and non-mandatory claims.
            </p>

            <p>
              The Derived Proof is generated by the holder, when presenting of the (derived) Credential.
              These data are combined with the kind of selective disclosure requests the holder is prepared to honor; it is the combination of all these data that are used for the creation of a Derived Proof that is forwarded to the verifier.
            </p>
          </section>
        </section>

        <section>
          <h4>A Complete Example with ECDSA</h4>

          <p>
            The Credential example, shown in <a href="#base_example"></a>, and enriched with a reference to a JSON Schema in <a href="#base_example_schema"></a>, can be secured via an embedded proof as follows:
          <p>

          <pre id="base_example_ecdsa" class="example nohighlight" title="An ECDSA proof added to a Credential">
            {
              "@context": [
                "https://www.w3.org/ns/credentials/v2",
                "https://www.example.org/vocabs/alumni"
              ],
              "id": "https://university.example/Credential123",
              "type": ["VerifiableCredential", "ExampleAlumniCredential"],
              "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
              "validFrom": "2010-01-01T00:00:00Z",
              "credentialSubject": {
                "id": "https://www.example.org/persons/pat",
                "name": "Pat",
                "alumniOf": {
                  "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
                  "name": "Example University"
                }
              },
              "credentialSchema" : {
                "id": "https://university.example/Credential123-schema-credential",
                "type": "JsonSchemaCredential"
              },
              "proof" : {
                "type": "DataIntegrityProof",
                "cryptosuite": "ecdsa-rdfc-2019",
                "created": "2010-01-01T00:00:00Z",
                "expires": "2040-01-01T00:00:00Z",
                "verificationMethod: "did:example:2g55q912ec3476eba2l9812ecbfe#ecdsa-public-key"
                "proofPurpose": "assertionMethod"
                "proofValue": "zQeVb…Wx"
              }
            }
          </pre>
          
          <p>
            When dereferenced, the URL `did:example:2g55q912ec3476eba2l9812ecbfe#ecdsa-public-key` should return a (public) ECDSA key in Multikey, for example:
          </p>
          
          <pre class="example nohighlight" title="An ECDSA public key">
            {
              "@context": [
                "https://www.w3.org/ns/did/v1",
                "https://w3id.org/security/multikey/v1"
              ],
              "id": "did:example:2g55q912ec3476eba2l9812ecbfe#ecdsa-public-key",
              "type": "Multikey",
              "controller": "did:example:2g55q912ec3476eba2l9812ecbfe",
              "publicKeyMultibase": "z42twTcNeSYcnqg1FLuSFs2bsGH3ZqbRHFmvS9XMsYhjxvHN"
            }
          </pre>
        </section>

      </section>
    </section>

    <section>
      <h2>Bitstring Status List</h2>
      <p>
        It is often useful for an issuer of verifiable credentials to link to a location where a verifier can check to see if a credential has been suspended or revoked. 
        This additional resource is referred to as a “status list”.
      </p>    
      <p>
        The simplest approach for a status list, where there is a one-to-one mapping between a Verifiable Credential and a URL where the status is published, raises privacy as well as performance issues.
        In order to meet privacy expectations, it is useful to bundle the status of large sets of credentials into a single list to help with group privacy. 
        However, doing so can place an impossible burden on both the server and client if the status information is as much as a few hundred bytes in size per credential across a population of hundreds of millions of holders.
        The [[[VC-BITSTRING-STATUS-LIST]]] [[VC-BITSTRING-STATUS-LIST]] specification defines a highly compressible, highly space-efficient bitstring-based status list mechanism.
        With this mechanism it is possible to create a status list where, in case a few hundred credentials have been revoked, the size of the list is less than a few hundred bytes while providing privacy in a group of 100,000 individuals.
      </p>

      <p>
        Conceptually, a bitstring status list is a sequence of bits. 
        When a single bit specifies a status, such as "revoked" or "suspended", then that status is expected to be true when the bit is set (1) and false when unset (0).
        One of the benefits of using a bitstring is that it is a highly compressible data format since, in the average case, large numbers of credentials will remain unrevoked.
        If compressed using run-length compression techniques such as gzip. 
        The default status list size is 131,072 entries, equivalent to 16 KB of single bit values. 
        When only a handful of verifiable credentials are revoked, GZIP compresses the bitstring to a few hundred bytes.
      </p>

      <figure id="bitstring-statuslist-concept">
        <img style="margin: auto; display: block; width: 65%;" src="diagrams/BitstringStatusListConcept.svg" alt="TBD">
        <figcaption style="text-align: center;">
          A visual depiction of the concepts outlined in this section.
        </figcaption>
      </figure>

      <p>
        The specification introduces the `credentialStatus` property that should be used to add this additional entry to a Verifiable Credential. 
        Our example from <a href="#base_example_ecdsa"></a> looks as follows, when expanded with a credential status:
      </p>

      <pre id="base_example_status_list" class="example nohighlight" title="Verifiable Credential with a Reference to a Status List">
        {
          "@context": [
            "https://www.w3.org/ns/credentials/v2",
            "https://www.example.org/vocabs/alumni"
          ],
          "id": "https://university.example/Credential123",
          "type": ["VerifiableCredential", "ExampleAlumniCredential"],
          "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
          "validFrom": "2010-01-01T00:00:00Z",
          "credentialSubject": {
            "id": "https://www.example.org/persons/pat",
            "name": "Pat",
            "alumniOf": {
              "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
              "name": "Example University"
            }
          },
          "credentialSchema" : {
            "id": "https://university.example/Credential123-schema-credential",
            "type": "JsonSchemaCredential"
          },
          "credentialStatus" : {
            "id": "https://university.example/statuslist#123456",
            "type": "BitstringStatusListEntry",
            "statusPurpose": "revocation",
            "statusListIndex": "123456",
            "statusListCredential": "https://university.example/CredentialStatusList"
          },
          "proof" : {
            "type": "DataIntegrityProof",
            "cryptosuite": "ecdsa-rdfc-2019",
            "created": "2010-01-01T00:00:00Z",
            "expires": "2040-01-01T00:00:00Z",
            "verificationMethod: "did:example:2g55q912ec3476eba2l9812ecbfe#ecdsa-public-key"
            "proofPurpose": "assertionMethod"
            "proofValue": "zQeVb…Wx"
          }
        }
      </pre>

      <p>
        Note the `statusListCredential` property; when dereferenced, it should return a Credential for the status list.
        The status list itself is the subject of that Credential (which, of course, can also be signed). An example is: 
      </p>

      <pre id="status_list_credential_example" class="example nohighlight" title="A Credential for a Bitstring Status List">
        {
          "@context": [
            "https://www.w3.org/ns/credentials/v2"
          ],
          "id": "https://university.example/CredentialStatusList",
          "type": ["VerifiableCredential", "BitstringStatusListCredential"],
          "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe"",
          "validFrom": "2005-01-01T00:00:00",
          "credentialSubject": {
            "id": "https://university.example/statuslist#list",
            "type": "BitstringStatusList",
            "statusPurpose": "revocation",
            "encodedList": "uH4sIAAAAAAAAA-3BMQEAAADCoPVPbQwfoAAAAAAAAAAAAAAAAAAAAIC3AYbSVKsAQAAA"
          }
        }
      </pre>

      <p>
        The core property in this case is `encodedList`, which is a base64url encoded version of the gzip compressed bitstring status list.
      </p>
    </section>

    <section class="appendix">
      <h3>Lifecycle Details</h3>
    
      <p>
        The previous sections provided an overview of the Verifiable Credential ecosystem. 
        This section provides more details about how the ecosystem is envisaged to operate.
      </p>
    
      <figure id="life-cycle-details">
        <img style="margin: auto; display: block; width: 85%;" src="diagrams/ecosystemdetail.svg" alt="diagram showing how
              credentials flow from issuer to holder, and optionally
              from one holder to another; and how
              presentations flow from holder to verifier,
              optionally from one verifier to another through verification and validation.
              All parties can use information from a logical
              verifiable data registry. Holder may also delete credential.">
        <figcaption style="text-align: center;">
          Lifecycle of a single Verifiable Credential: the roles and information flows for this specification.
        </figcaption>
      </figure>
          
      <p>
        The roles and information flows in the Verifiable Credential ecosystem are as follows:
      </p>
    
      <ul>
        <li>
          An issuer issues a Verifiable Credential to a holder. 
          Issuance always occurs before any other actions involving a Credential.
        </li>
        <li>
          A holder might transfer one or more of its Verifiable credentials to another holder.
        </li>
        <li>
          A holder presents one or more of its verifiable credentials to a verifier, optionally inside a Verifiable Presentation.
        </li>
        <li>
          A verifier verifies the authenticity of the presented Verifiable Presentation and Verifiable Credentials and checks any credential status (if present) of the Verifiable Credentials.
        </li>
        <li>
          After verification, a verifier validates the relevant claims in presented Verifiable Credentials, using their own business logic to evaluate which issuers are appropriate for which claims and which subjects are appropriate for the requested use.
        </li>
        <li>
          An issuer might revoke a Verifiable Credential.
        </li>
        <li>
          A holder might delete a Verifiable credential.
        </li>
      </ul>
    
      <p class="note">
        The order of the actions above is not fixed, and some actions might be taken more than once. Such action-recurrence might be immediate or at any later point.
      </p>
    
      <p>
        The most common sequence of actions is envisioned to be:
      </p>
    
      <ol>
        <li>
          An issuer issues a verifiable credential to a holder.
        </li>
        <li>
          The holder presents to a verifier.
        </li>
        <li>
          The verifier verifies.
        </li>
        <li>
          The verifier validates claims.
        </li>
        <li>
          The verifier applies valid claims.
        </li>
      </ol>
    
      <p>
        These specifications do not define any protocol for transferring Verifiable Credentials or Verifiable Presentations, but assuming other specifications do specify how they are transferred between entities, then this Verifiable Credential Data Model is directly applicable.
      </p>
    
      <p>
        These specifications neither define an authorization framework nor does it restrict the business decisions that a verifier might make after verifying a Verifiable Credential or Verifiable presentation. 
        Rather, verifiers apply their own business rules before treating any claim as valid, taking into account the holder, the issuer of the Verifiable Credential, the claims of the Verifiable credential, and the verifier’s own policies.
      </p>
    
      <p>
        In particular, Sections <a data-cite="VC-DATA-MODEL-2.0#terms-of-use"></a> and the <a href="https://w3c.github.io/vc-imp-guide/#subject-holder-relationships"> Subject-Holder Relationships</a> section in the Verifiable Credentials Implementation Guide [[VC-IMP-GUIDE]] specify how a verifier can determine:
      </p>
    
      <ul>
        <li>
          Whether the holder is a subject of a verifiable credential.
        </li>
        <li>
          The relationship between the subject and the holder.
        </li>
        <li>
          Whether the original holder passed a verifiable credential to a subsequent holder.
        </li>
        <li>
          Any restrictions using the Verifiable credentials by the holder or verifier.
        </li>
      </ul>
    </section>

  </body>

</html>
